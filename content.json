{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"ActiveMQ集群","text":"下载activemqapache-activemq-5.15.9-bin.tar.gz 搭建zookeeper伪集群localhost:2181,localhost:2182,localhost:2183 伪集群部署解压 activemq 去 activemq.xml中添加配置 1234567891011&lt;!-- 持久化的部分为ZooKeeper集群连接地址--&gt; &lt;persistenceAdapter&gt; &lt;replicatedLevelDB directory=\"${activemq.data}/leveldb\" replicas=\"3\" bind=\"tcp://0.0.0.0:0\" zkAddress=\"localhost:2181,localhost:2182,localhost:2183\" zkPath=\"/usr/local/activemq/leveldb-stores\" hostname=\"localhost\" /&gt; &lt;/persistenceAdapter&gt; 把整个activemq 目录复制几份,修改端口依次启动即可 结论集群中 activemq 至少有2台存活时，消息一切正常，低于2台时，消息阻塞，将会一直等待mq恢复 集群中zk超过半数正常，整个集群正常，少于半数，则mq也会受到影响","link":"/2019/09/03/ActiveMQ集群/"},{"title":"Maven常用指令","text":"Maven 常用指令打包跳过测试类 mvn clean install -DskipTests","link":"/2019/08/13/Maven/"},{"title":"Mongo常用指令","text":"分页查询1db.getCollection('sensor_tilt_alarm').find({ }).limit(200).sort({ \"_id\" : -1 }) 时间区间查询1db.getCollection('t_2010090117060001').find({'createdAt':{'$gte': new ISODate(\"2017-06-27\"),'$lt': new ISODate(\"2017-06-27T12:59:59.680Z\")}}).limit(10000).sort({ \"Time\" : -1 })","link":"/2019/08/21/Mongo基本操作/"},{"title":"Spring注解详解","text":"@AliasFor被这个注解标识的2个属性，赋值的时候只有一个属性能赋值，都赋值就会报错。只要有一个被赋值，随便获取哪个属性都能获取到被赋的值。","link":"/2019/08/06/Spring-annotation/"},{"title":"AQS执行原理","text":"在多线程并发的时候吧，第一个线程拿到了锁，其他线程则会在获取不到锁的时候被加到一个双向链表中排队，并且自旋循环，等到他的他的前一个节点变成头并且自己获取到锁的时候就会停止自旋 CLH是什么CLH锁即Craig, Landin, and Hagersten (CLH) locks。CLH锁是一个自旋锁。能确保无饥饿性。提供先来先服务的公平性。 CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。 ReentrantLock执行原理这个类有2个构造方法 1234567891011121314151617/** * Creates an instance of {@code ReentrantLock}. * This is equivalent to using {@code ReentrantLock(false)}. */public ReentrantLock() { sync = new NonfairSync();}/** * Creates an instance of {@code ReentrantLock} with the * given fairness policy. * * @param fair {@code true} if this lock should use a fair ordering policy */public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();} 见名知义 ReentrantLock 默认使用的是非公平锁， 你也可以根据参数来决定是什么锁 执行流程 一旦调用 lock.lock(); 方法 就会执行java.util.concurrent.locks.ReentrantLock.NonfairSync#lock方法， 该方法会判断这个线程有没有被锁住，没有锁住就锁住当前线程，锁住的话就执行java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire方法 acquire 方法会调用addWaiter(Node.EXCLUSIVE) 方法把当前线程当做一个node加入到一个双向链表中，而且是加到列表最后 1234567891011121314private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node;} 接着acquire 方法会调用acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 方法让当前节点无限循环判断当前节点的前一个节点是不是head节点并且head节点已经释放了lock的时候，当前节点设置为head节点，获取到lock。其实每一个加入链表中的节点都会加到末尾，并让他们自旋知道自己前一个节点是head节点并且释放锁后就停止自旋，依次加锁释放锁。 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); }}","link":"/2019/07/11/AQS原理/"},{"title":"ActiveMQ源码启动","text":"ActiveMQ的版本为 5.15.9 activemq编译流程 下载源码，然后导入idea里面 进入项目目录执行mvn clean install -Dmaven.test.skip=true 编译，编译可能会出问题，可以按照提示排除，一般问题都能解决，可能会出现有某一个模块怎么编译都有问题，那就先把这个模块去掉 编译通过后，进入activemq-console模块的Main方法下启动项目，但是启动前先做一些配置， 12System.setProperty(\"activemq.base\", \"D:\\\\ideaworkspace\\\\activemq-parent-5.15.9-source-release\\\\activemq-parent-5.15.9\\\\temp\");System.setProperty(\"activemq.home\", \"D:\\\\ideaworkspace\\\\activemq-parent-5.15.9-source-release\\\\activemq-parent-5.15.9\\\\temp\"); 把以上代码加入项目中，然后在项目中新建一个temp目录，把 D:\\ideaworkspace\\activemq-parent-5.15.9-source-release\\activemq-parent-5.15.9\\assembly\\target 目录下的 activemq.bin.zip解压放入temp下，注解temp目录下必须是bin，conf等目录 启动Main方法 加入参数 start broker:(tcp://localhost:61616,tcp://localhost:5000)?useJmx=true 即可启动 activemq源码启动流程 进入根目录 mvn clean install -DskipTests 编译项目 加入mysql驱动和spring-jdbc的jar包 运行activemq进入assembly 项目 test包下运行 IDETest 注意要修改一下用junit运行 activemq控制台打印修改找到activemq-all 项目的log4j文件进行修改 activemq mqtt debugactivemq-broker 靠 org.apache.activemq.transport.tcp.TcpTransport#readCommand 方法接收mqtt客户端发来的数据 最终由 org.apache.activemq.transport.mqtt.MQTTProtocolConverter#onMQTTPublish 方法把数据发送到 activeMq 修改 activemq 打包带哪些jar修改以下文件即可 activemq-parent-5.15.9\\assembly\\src\\main\\descriptors\\common-bin.xml mq queue debug队列接收消息的方法 org.apache.activemq.broker.region.Queue#doMessageSend 队列消息分法 org.apache.activemq.broker.region.Queue#doActualDispatch broker收到consumer的响应 org.apache.activemq.broker.region.Queue#acknowledge 消息的发送 org.apache.activemq.broker.TransportConnection#dispatch 往 topic里面发消息会被 ``` 处理12345678910111213141516往queue里面发的消息也会被```org.apache.activemq.transport.TransportSupport#doConsume```处理## 如何设置自动删除不活跃的队列或主题在broker标签下面的 destinationPolicy 里面加入 2个属性gcInactiveDestinations=&quot;true&quot; inactiveTimoutBeforeGC=&quot;604800000&quot;并且 broker 标签上 加入schedulePeriodForDestinationPurge=&quot;60000&quot;定时扫描， 上面的示例是60秒。 &lt;policyEntry queue=&quot;&gt;&quot; gcInactiveDestinations=&quot;true&quot; inactiveTimoutBeforeGC=&quot;604800000&quot;/&gt; &lt;/policyEntries&gt; &lt;/policyMap&gt; &lt;/destinationPolicy&gt;123456``` &lt;policyEntry queue=&quot;&gt;&quot; gcInactiveDestinations=&quot;true&quot; inactiveTimoutBeforeGC=&quot;604800000&quot;/&gt;","link":"/2019/08/06/ActiveMQ源码启动流程/"},{"title":"Spring-batch 详解","text":"各个表的含义123456789batch_job_execution (执行任务详情，成功，失败，时间等)batch_job_execution_context ()batch_job_execution_params (执行任务的参数表)batch_job_execution_seq (序列号)batch_job_instance (执行任务记录)batch_job_seq (序列号)batch_step_execution (步奏记录表)batch_step_execution_contextbatch_step_execution_seq (序列号) 碰到的一些问题 (A job instance already exists and is complete for parameters={run.id=1}. If you want to run this job again, change the parameters.) 这个问题是同一个job只执行一遍，job会根据parameters判断是不是同一个任务，已经执行的任务就不会再执行了","link":"/2019/07/19/Spring-batch详解/"},{"title":"Mqtt协议讲解","text":"MQTT 数据包结构1MqttPublishMessage[fixedHeader=MqttFixedHeader[messageType=PUBLISH, isDup=false, qosLevel=AT_MOST_ONCE, isRetain=false, remainingLength=8], variableHeader=MqttPublishVariableHeader[topicName=test, packetId=-1], payload=PooledSlicedByteBuf(ridx: 0, widx: 2, cap: 2/2, unwrapped: PooledUnsafeDirectByteBuf(ridx: 10, widx: 10, cap: 1024))] 固定头（Fixed header），存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识 可变头（Variable header），存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容 消息体（Payload），存在于部分MQTT数据包中，表示客户端收到的具体内容 固定头由2个byte组成 1个byte=8bit （这里要理清楚哪边是高位） 例如16 = 0001 0000 bit0-3 = 0000 retain = 0, qos = 00, dup = 0 ） 第一个byte 分为8bit bit0-bit3表示 bit0 = retain(发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。) bit1-2 = qos 发布消息的服务质量，即：保证消息传递的次数 00：最多一次，即：&lt;=1 01：至少一次，即：&gt;=1 10：一次，即：=1 11：预留 bit3 = dup (发布消息的副本。用来在保证消息的可靠传输，如果设置为 1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。) bit4-7 消息类型 （例如16 = 0001 0000 bit4-7 = 0001 = 1 = CONNECT ） 名称 值 流方向 描述 Reserved 0 不可用 保留位 CONNECT 1 客户端到服务器 客户端请求连接到服务器 CONNACK 2 服务器到客户端 连接确认 PUBLISH 3 双向 发布消息 PUBACK 4 双向 发布确认 PUBREC 5 双向 发布收到（保证第1部分到达） PUBREL 6 双赂 发布释放（保证第2部分到达） PUBCOMP 7 双向 发布完成（保证第3部分到达） SUBSCRIBE 8 客户端到服务器 客户端请求订阅 SUBACK 9 服务器到客户端 订阅确认 UNSUBSCRIBE 10 客户端到服务器 请求取消订阅 UNSUBACK 11 服务器到客户端 取消订阅确认 PINGREQ 12 客户端到服务器 PING请求 PINGRESP 13 服务器到客户端 PING应答 DISCONNECT 14 客户端到服务器 中断连接 Reserved 15 不可用 保留位 第二个byte 消息的长度最终结构 Description 7 6 5 4 3 2 1 0 Fixed header/固定头部 Message Type(1) DUP flag QoS level RETAIN byte 1 0 0 0 1 x x x x byte 2 Remaining Length Variable header/可变头部 Protocol Name byte 1 Length MSB (0) 0 0 0 0 0 0 0 0 byte 2 Length LSB (6) 0 0 0 0 0 1 1 0 byte 3 &apos;M&apos; 0 1 0 0 1 1 0 1 byte 4 &apos;Q&apos; 0 1 0 1 0 0 0 1 byte 5 &apos;I&apos; 0 1 0 0 1 0 0 1 byte 6 &apos;s&apos; 0 1 1 1 0 0 1 1 byte 7 &apos;d&apos; 0 1 1 0 0 1 0 0 byte 8 &apos;p&apos; 0 1 1 1 0 0 0 0 Protocol Version Number byte 9 Version (3) 0 0 0 0 0 0 1 1 Connect Flags User Name Flag Password Flag Will Retain Will QoS Will Flag Clean Session Reserved byte 10 1 1 0 0 1 1 1 x Keep Alive timer byte 11 Keep Alive MSB (0) 0 0 0 0 0 0 0 0 byte 12 Keep Alive LSB (10) 0 0 0 0 1 0 1 0 Playload/消息体 Client Identifier(客户端ID) 1-23个字符长度，客户端到服务器的全局唯一标志，如果客户端ID超出23个字符长度，服务器需要返回码为2，标识符被拒绝响应的CONNACK消息。 处理QoS级别1和2的消息ID中，可以使用到。 必填项。 Will Topic Will Flag值为1，这里便是Will Topic的内容。QoS级别通过Will QoS字段定义，RETAIN值通过Will RETAIN标识，都定义在可变头里面。 Will Message Will Flag若设为1，这里便是Will Message定义消息的内容，对应的主题为Will Topic。如果客户端意外的断开触发服务器PUBLISH此消息。 长度有可能为0。 在CONNECT消息中的Will Message是UTF-8编码的，当被服务器发布时则作为二进制的消息体。 User Name 如果设置User Name标识，可以在此读取用户名称。一般可用于身份验证。协议建议用户名为不多于12个字符，不是必须。 Password 如果设置Password标识，便可读取用户密码。建议密码为12个字符或者更少，但不是必须。","link":"/2019/07/26/Mqtt/"},{"title":"Git问题详解","text":"IDEA 提交项目到github时出现异常1Push failed: Failed with error: Could not read from remote repository. 以上这个异常的解决办法 到需要提交的项目的根目录使用命令,查看地址和github上的地址是否一致，不一致则修改 1git remote -v 123$ git remote -vorigin https://github.com/467812367/leetcode.git (fetch)origin https://github.com/467812367/leetcode.git (push) 我的已经改过所以没问题。 没改过的是下面这样 123$ git remote -vorigin git@github.com/467812367/leetcode.git (fetch)origin git@github.com/467812367/leetcode.git (push) 需要重新设置URL再提交即可, 以下命令设置URL 1git remote set-url origin https://github.com/467812367/leetcode.git","link":"/2019/08/15/Git遇见的问题/"},{"title":"Hexo+Gitpages 搭建流程","text":"首先安装 nodejs npm -version 出现版本，则安装成功 安装 hexo-cli 1npm install -g hexo-cli 创建目录 1mkdir hexo_blog 初始化hexo 1hexo init hexo_blog 进入目录 1cd hexo_blog 5 . 安装 1npm install 启动hexo 服务 (访问localhost:4000 成功则ok) 1hexo server 修改配置文件 （_config.yml） Theme目录下面deploy:type: gitrepo: https://github.com/467812367/467812367.github.io.gitbranch: master 安装部署插件 1npm install hexo-deployer-git 部署到github上 1hexo d 先清除，后部署 (清除部署)（要输入账户密码） 1hexo clean &amp;&amp; hexo d","link":"/2019/07/30/hexo+gitpages/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/04/hello-world/"},{"title":"ActiveMQ 教程","text":"ActiveMQ的一些特性和参数 AUTO_ACKNOWLEDGE = 1 自动确认 CLIENT_ACKNOWLEDGE = 2 客户端手动确认 DUPS_OK_ACKNOWLEDGE = 3 自动批量确认 SESSION_TRANSACTED = 0 事务提交并确认 INDIVIDUAL_ACKNOWLEDGE = 4 单条消息确认 activemq 独有 ActiveMQ 到底是推还是拉？ ActiveMQ默认是主动给consumer推送消息，默认到1000条consumer还未消费完就停止推送了。直到小于1000条，就会自动推送。 如果想要让consumer主动去拉，得把prefetchSize设置为0（默认1000），之后才能主动去拉 1Destination destination = session.createQueue(\"test-queue?consumer.prefetchSize=0\"); queue 和 topic 区别queue的特性 消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费、其它的则不能消费此消息了。当消费者不存在时，消息会一直保存，直到有消费消费 支持集群消费队列消息，开启多个消费者即可 topic的特性 消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。当生产者发布消息，不管是否有消费者。都不会保存消息，意味着用户如果离线，消息再也不会被收到 只有创建durableSubscriber（持久化的订阅者）才会保存消息，用户离线了再上线，还是可以收到消息 不支持集群消费，开启多个消费者都能分别收到同样的消息，如何给每个消费者设置同一个ClientId的话，则只有一个能连上。 activemq的一些玩法① 可以一次性往多个主题或者队列里发送数据 生产者代码： 1234567891011121314151617ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);Connection connection = null;try { connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(\"test-queue,test-queue-foo,test-queue-bar,topic://test-topic-foo\"); MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; NUM_MESSAGES_TO_SEND; i++) { TextMessage message = session.createTextMessage(\"Message #\" + i); System.out.println(\"Sending message #\" + i); producer.send(message); Thread.sleep(DELAY); } 消费者代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263try { connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(\"test-queue\"); Destination destinationFoo = session.createQueue(\"test-queue-foo\"); Destination destinationBar = session.createQueue(\"test-queue-bar\"); Destination destinationTopicFoo = session.createTopic(\"test-topic-foo\"); MessageConsumer consumer = session.createConsumer(destination); MessageConsumer consumerFoo = session.createConsumer(destinationFoo); MessageConsumer consumerBar = session.createConsumer(destinationBar); MessageConsumer consumerTopicFoo = session.createConsumer(destinationTopicFoo); int i = 0; while (true) { Message message = consumer.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message on test-queue: \" + text); } } else { break; } message = consumerFoo.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message on test-queue-foo: \" + text); } } else { break; } message = consumerBar.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message on test-queue-bar: \" + text); } } else { break; } message = consumerTopicFoo.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message on test-topic-bar: \" + text); } } else { break; } } ②创建一个持久性的订阅者 1234567891011121314151617181920212223try { System.setProperty(\"clientId\",\"jiangwz\"); connection = connectionFactory.createConnection(); String clientId = System.getProperty(\"clientId\"); System.out.println(clientId); connection.setClientID(clientId); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Topic destination = session.createTopic(\"test-topic\"); MessageConsumer consumer = session.createDurableSubscriber(destination, clientId) ; consumer.setMessageListener(new Subscriber(latch)); latch.await(); consumer.close(); session.close();} catch (Exception e) { System.out.println(\"Caught exception!\");} ③队列排他消费 默认情况下一个队列多个消费者会出现负载均衡的状况，如果你想只让一个消费者消费，其他消费者都消费不到消息，只要在队列后面加上?consumer.exclusive=true就可以了（只有第一个消费的人能够消费到，先来先消费），可以看如下代码： 1234567891011121314151617181920212223242526272829try { connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Queue destination = session.createQueue(\"test-queue?consumer.exclusive=true\"); MessageConsumer consumer = session.createConsumer(destination); int i = 0; while (true) { Message message = consumer.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message: \" + text); } } else { break; } } consumer.close(); session.close();} catch (Exception e) { System.out.println(\"Caught exception!\");} ④未读消息浏览功能（browser） 只要消息未被读取（因为默认mq会把已读的消息删除掉），可以先去队列里面查看里面消息的内容 123456789101112131415161718192021try { connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Queue destination = session.createQueue(\"test-queue\"); QueueBrowser browser = session.createBrowser(destination); Enumeration enumeration = browser.getEnumeration(); while (enumeration.hasMoreElements()) { TextMessage message = (TextMessage) enumeration.nextElement(); System.out.println(\"Browsing: \" + message); TimeUnit.MILLISECONDS.sleep(DELAY); } session.close();} catch (Exception e) { System.out.println(\"Caught exception!\");} ⑤消息选择器（messageSelector） 发的时候可以加属性 1234567891011121314151617181920212223242526272829try { connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(\"test-queue\"); MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; NUM_MESSAGES_TO_SEND; i++) { TextMessage message = session.createTextMessage(\"Message #\" + i); System.out.println(\"Sending message #\" + i); if (i % 2 == 0) { System.out.println(\"Sending to me\"); message.setStringProperty(\"intended\", \"me\"); } else { System.out.println(\"Sending to you\"); message.setStringProperty(\"intended\", \"you\"); } producer.send(message); Thread.sleep(DELAY); } producer.close(); session.close();} catch (Exception e) { System.out.println(\"Caught exception!\");} 消费的时候 可以指定 （intended = ‘you’）定向消费到you里面的消息（而不会消费到me里面的数据），不写messageSelector能消费到队列里所有数据 1234567891011121314151617181920212223242526272829try { connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(\"test-queue\"); MessageConsumer consumer = session.createConsumer(destination, \"intended = 'you'\"); int i = 0; while (true) { Message message = consumer.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message: \" + text); } } else { break; } } consumer.close(); session.close();} catch (Exception e) { System.out.println(\"Caught exception!\");} ⑥ 临时队列 （TemporaryQueue）一般用于生产者给消费者发消息，需要消费者收到消息后，回一条消息时用到生产者代码： 123456789101112131415161718192021222324252627282930313233try { connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(\"test-queue\"); MessageProducer producer = session.createProducer(destination); Destination replyDest = session.createTemporaryQueue(); // set up the consumer to handle the reply MessageConsumer replyConsumer = session.createConsumer(replyDest); replyConsumer.setMessageListener(new MessageListener() { @Override public void onMessage(Message message) { System.out.println(\"*** REPLY *** \"); System.out.println(message.toString()); } }); TextMessage message = session.createTextMessage(\"I need a response for this, please\"); message.setJMSReplyTo(replyDest); producer.send(message); // wait for a response TimeUnit.SECONDS.sleep(2); producer.close(); session.close();} catch (Exception e) { System.out.println(\"Caught exception!\");} 消费者代码： 1234567891011121314151617181920212223242526272829303132try { connection = connectionFactory.createConnection(); connection.start(); final Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(\"test-queue\"); MessageConsumer consumer = session.createConsumer(destination); int i = 0; while (true) { Message message = consumer.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message: \" + text); Destination replyTo = message.getJMSReplyTo(); MessageProducer producer = session.createProducer(replyTo); producer.send(session.createTextMessage(\"You made it to the consumer, here is your response\")); producer.close(); } } else { break; } } consumer.close(); session.close(); } catch (Exception e) { System.out.println(\"Caught exception!\"); } ⑦ 消费者有2中消费方法 调用receive方法阻塞获取 1Message message = consumer.receive(TIMEOUT); 设置一个监听器获取 1consumer.setMessageListener(new Subscriber(latch)); ⑧ 可以用*号 匹配所有主题进行消费 例如 hello.* 可以匹配 hello.1,hello.2主题下面的所有消息，必须.相连才行 控制台密码修改 先查看jetty.xml文件里面验证有没有开启, authenticate = true 开启 123456&lt;bean id=\"securityConstraint\" class=\"org.eclipse.jetty.util.security.Constraint\"&gt; &lt;property name=\"name\" value=\"BASIC\" /&gt; &lt;property name=\"roles\" value=\"user,admin\" /&gt; &lt;!-- set authenticate=false to disable login --&gt; &lt;property name=\"authenticate\" value=\"true\" /&gt;&lt;/bean&gt; 去conf/jetty-realm.properties 里面修改用户 分别是 账户：密码，角色 1234--- Defines users that can access the web (console, demo, etc.)--- username: password [,rolename ...]root: root, adminuser: user, user 修改连接密码在 activeMQ的 activemq.xml里面的broker标签里面加入以下配置 12345678&lt;!-- 添加访问ActiveMQ的账号密码 --&gt; &lt;plugins&gt; &lt;simpleAuthenticationPlugin&gt; &lt;users&gt; &lt;authenticationUser username=&quot;admin&quot; password=&quot;admin&quot; groups=&quot;users,admins&quot;/&gt; &lt;/users&gt; &lt;/simpleAuthenticationPlugin&gt; &lt;/plugins&gt; 修改连接密码后，可能导致控制台访问异常，例如查看队列里面的消息出问题，这时一定要修改credentials.properties文件里面的账户和上面配置的密码一致 activemq.username=admin activemq.password=admin guest.password=password","link":"/2019/07/25/ActiveMQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","link":"/tags/消息中间件/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Mongo","slug":"Mongo","link":"/tags/Mongo/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Spring-batch","slug":"Spring-batch","link":"/tags/Spring-batch/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"}],"categories":[{"name":"MQ","slug":"MQ","link":"/categories/MQ/"},{"name":"Maven","slug":"Maven","link":"/categories/Maven/"},{"name":"Mongo","slug":"Mongo","link":"/categories/Mongo/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Spring-batch","slug":"Spring-batch","link":"/categories/Spring-batch/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"}]}