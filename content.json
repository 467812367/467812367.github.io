{"pages":[],"posts":[{"title":"","text":"ABS执行原理在多线程并发的时候吧，第一个线程拿到了锁，其他线程则会在获取不到锁的时候被加到一个双向链表中排队，并且自旋循环，等到他的他的前一个节点变成头并且自己获取到锁的时候就会停止自旋","link":"/2019/07/11/AQS原理/"},{"title":"","text":"title:ActiveMQ 教程 AUTO_ACKNOWLEDGE = 1 自动确认 CLIENT_ACKNOWLEDGE = 2 客户端手动确认 DUPS_OK_ACKNOWLEDGE = 3 自动批量确认 SESSION_TRANSACTED = 0 事务提交并确认 INDIVIDUAL_ACKNOWLEDGE = 4 单条消息确认 activemq 独有 queue 和 topic 区别queue的特性 消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费、其它的则不能消费此消息了。当消费者不存在时，消息会一直保存，直到有消费消费 topic的特性 消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。当生产者发布消息，不管是否有消费者。都不会保存消息，意味着用户如果离线，消息再也不会被收到 只有创建durableSubscriber（持久化的订阅者）才会保存消息，用户离线了再上线，还是可以收到消息 activemq的一些玩法① 可以一次性往多个主题或者队列里发送数据 生产者代码： 123456789101112131415try { connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(\"test-queue,test-queue-foo,test-queue-bar,topic://test-topic-foo\"); MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; NUM_MESSAGES_TO_SEND; i++) { TextMessage message = session.createTextMessage(\"Message #\" + i); System.out.println(\"Sending message #\" + i); producer.send(message); Thread.sleep(DELAY); } 消费者代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263try { connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(NON_TRANSACTED, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(\"test-queue\"); Destination destinationFoo = session.createQueue(\"test-queue-foo\"); Destination destinationBar = session.createQueue(\"test-queue-bar\"); Destination destinationTopicFoo = session.createTopic(\"test-topic-foo\"); MessageConsumer consumer = session.createConsumer(destination); MessageConsumer consumerFoo = session.createConsumer(destinationFoo); MessageConsumer consumerBar = session.createConsumer(destinationBar); MessageConsumer consumerTopicFoo = session.createConsumer(destinationTopicFoo); int i = 0; while (true) { Message message = consumer.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message on test-queue: \" + text); } } else { break; } message = consumerFoo.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message on test-queue-foo: \" + text); } } else { break; } message = consumerBar.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message on test-queue-bar: \" + text); } } else { break; } message = consumerTopicFoo.receive(TIMEOUT); if (message != null) { if (message instanceof TextMessage) { String text = ((TextMessage) message).getText(); System.out.println(\"Got \" + i++ + \". message on test-topic-bar: \" + text); } } else { break; } }","link":"/2019/07/25/ActiveMQ/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/04/hello-world/"},{"title":"","text":"Spring-batch 详解各个表的含义123456789batch_job_execution (执行任务详情，成功，失败，时间等)batch_job_execution_context ()batch_job_execution_params (执行任务的参数表)batch_job_execution_seq (序列号)batch_job_instance (执行任务记录)batch_job_seq (序列号)batch_step_execution (步奏记录表)batch_step_execution_contextbatch_step_execution_seq (序列号) 碰到的一些问题 (A job instance already exists and is complete for parameters={run.id=1}. If you want to run this job again, change the parameters.) 这个问题是同一个job只执行一遍，job会根据parameters判断是不是同一个任务，已经执行的任务就不会再执行了","link":"/2019/07/19/Spring-batch详解/"}],"tags":[],"categories":[]}